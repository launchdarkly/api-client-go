/*
 * LaunchDarkly REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 2.0
 * Contact: support@launchdarkly.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ldapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ScheduledChangesApiService ScheduledChangesApi service
type ScheduledChangesApiService service

type ApiDeleteFlagConfigScheduledChangesRequest struct {
	ctx _context.Context
	ApiService *ScheduledChangesApiService
	projectKey string
	featureFlagKey string
	environmentKey string
	id string
}


func (r ApiDeleteFlagConfigScheduledChangesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteFlagConfigScheduledChangesExecute(r)
}

/*
 * DeleteFlagConfigScheduledChanges Delete scheduled changes workflow
 *  Delete a scheduled changes workflow
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectKey The project key
 * @param featureFlagKey The feature flag's key
 * @param environmentKey The environment key
 * @param id The scheduled change id
 * @return ApiDeleteFlagConfigScheduledChangesRequest
 */
func (a *ScheduledChangesApiService) DeleteFlagConfigScheduledChanges(ctx _context.Context, projectKey string, featureFlagKey string, environmentKey string, id string) ApiDeleteFlagConfigScheduledChangesRequest {
	return ApiDeleteFlagConfigScheduledChangesRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		featureFlagKey: featureFlagKey,
		environmentKey: environmentKey,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *ScheduledChangesApiService) DeleteFlagConfigScheduledChangesExecute(r ApiDeleteFlagConfigScheduledChangesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduledChangesApiService.DeleteFlagConfigScheduledChanges")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", _neturl.PathEscape(parameterToString(r.projectKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"featureFlagKey"+"}", _neturl.PathEscape(parameterToString(r.featureFlagKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentKey"+"}", _neturl.PathEscape(parameterToString(r.environmentKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetFeatureFlagScheduledChangeRequest struct {
	ctx _context.Context
	ApiService *ScheduledChangesApiService
	projectKey string
	featureFlagKey string
	environmentKey string
	id string
}


func (r ApiGetFeatureFlagScheduledChangeRequest) Execute() (ScheduledChangesRep, *_nethttp.Response, error) {
	return r.ApiService.GetFeatureFlagScheduledChangeExecute(r)
}

/*
 * GetFeatureFlagScheduledChange Get a scheduled change
 *  Gets a scheduled change that will be applied to the feature flag by id.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectKey The project key
 * @param featureFlagKey The feature flag's key
 * @param environmentKey The environment key
 * @param id The scheduled change id
 * @return ApiGetFeatureFlagScheduledChangeRequest
 */
func (a *ScheduledChangesApiService) GetFeatureFlagScheduledChange(ctx _context.Context, projectKey string, featureFlagKey string, environmentKey string, id string) ApiGetFeatureFlagScheduledChangeRequest {
	return ApiGetFeatureFlagScheduledChangeRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		featureFlagKey: featureFlagKey,
		environmentKey: environmentKey,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return ScheduledChangesRep
 */
func (a *ScheduledChangesApiService) GetFeatureFlagScheduledChangeExecute(r ApiGetFeatureFlagScheduledChangeRequest) (ScheduledChangesRep, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ScheduledChangesRep
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduledChangesApiService.GetFeatureFlagScheduledChange")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", _neturl.PathEscape(parameterToString(r.projectKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"featureFlagKey"+"}", _neturl.PathEscape(parameterToString(r.featureFlagKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentKey"+"}", _neturl.PathEscape(parameterToString(r.environmentKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFlagConfigScheduledChangesRequest struct {
	ctx _context.Context
	ApiService *ScheduledChangesApiService
	projectKey string
	featureFlagKey string
	environmentKey string
}


func (r ApiGetFlagConfigScheduledChangesRequest) Execute() (ScheduledChangesCollectionRep, *_nethttp.Response, error) {
	return r.ApiService.GetFlagConfigScheduledChangesExecute(r)
}

/*
 * GetFlagConfigScheduledChanges List scheduled changes
 *  Get a list of scheduled changes that will be applied to the feature flag.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectKey The project key
 * @param featureFlagKey The feature flag's key
 * @param environmentKey The environment key
 * @return ApiGetFlagConfigScheduledChangesRequest
 */
func (a *ScheduledChangesApiService) GetFlagConfigScheduledChanges(ctx _context.Context, projectKey string, featureFlagKey string, environmentKey string) ApiGetFlagConfigScheduledChangesRequest {
	return ApiGetFlagConfigScheduledChangesRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		featureFlagKey: featureFlagKey,
		environmentKey: environmentKey,
	}
}

/*
 * Execute executes the request
 * @return ScheduledChangesCollectionRep
 */
func (a *ScheduledChangesApiService) GetFlagConfigScheduledChangesExecute(r ApiGetFlagConfigScheduledChangesRequest) (ScheduledChangesCollectionRep, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ScheduledChangesCollectionRep
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduledChangesApiService.GetFlagConfigScheduledChanges")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", _neturl.PathEscape(parameterToString(r.projectKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"featureFlagKey"+"}", _neturl.PathEscape(parameterToString(r.featureFlagKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentKey"+"}", _neturl.PathEscape(parameterToString(r.environmentKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFlagConfigScheduledChangesConflictsRequest struct {
	ctx _context.Context
	ApiService *ScheduledChangesApiService
	projectKey string
	featureFlagKey string
	environmentKey string
	webReportFlagScheduledChangesInput *WebReportFlagScheduledChangesInput
}

func (r ApiGetFlagConfigScheduledChangesConflictsRequest) WebReportFlagScheduledChangesInput(webReportFlagScheduledChangesInput WebReportFlagScheduledChangesInput) ApiGetFlagConfigScheduledChangesConflictsRequest {
	r.webReportFlagScheduledChangesInput = &webReportFlagScheduledChangesInput
	return r
}

func (r ApiGetFlagConfigScheduledChangesConflictsRequest) Execute() (WebConflictResponse, *_nethttp.Response, error) {
	return r.ApiService.GetFlagConfigScheduledChangesConflictsExecute(r)
}

/*
 * GetFlagConfigScheduledChangesConflicts List conflicts for proposed instructions
 *  Compare the proposed instructions with each other and the existing scheduled changes to find conflicts that would prevent the existing scheduled changes from executing correctly if the proposed instructions were saved. PLEASE NOTE that this requires the WebDAV REPORT method and not the POST method.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectKey The project key
 * @param featureFlagKey The feature flag's key
 * @param environmentKey The environment key
 * @return ApiGetFlagConfigScheduledChangesConflictsRequest
 */
func (a *ScheduledChangesApiService) GetFlagConfigScheduledChangesConflicts(ctx _context.Context, projectKey string, featureFlagKey string, environmentKey string) ApiGetFlagConfigScheduledChangesConflictsRequest {
	return ApiGetFlagConfigScheduledChangesConflictsRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		featureFlagKey: featureFlagKey,
		environmentKey: environmentKey,
	}
}

/*
 * Execute executes the request
 * @return WebConflictResponse
 */
func (a *ScheduledChangesApiService) GetFlagConfigScheduledChangesConflictsExecute(r ApiGetFlagConfigScheduledChangesConflictsRequest) (WebConflictResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WebConflictResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduledChangesApiService.GetFlagConfigScheduledChangesConflicts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes-conflicts"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", _neturl.PathEscape(parameterToString(r.projectKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"featureFlagKey"+"}", _neturl.PathEscape(parameterToString(r.featureFlagKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentKey"+"}", _neturl.PathEscape(parameterToString(r.environmentKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.webReportFlagScheduledChangesInput == nil {
		return localVarReturnValue, nil, reportError("webReportFlagScheduledChangesInput is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webReportFlagScheduledChangesInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchFlagConfigScheduledChangeRequest struct {
	ctx _context.Context
	ApiService *ScheduledChangesApiService
	projectKey string
	featureFlagKey string
	environmentKey string
	id string
	webFlagScheduledChangesInput *WebFlagScheduledChangesInput
}

func (r ApiPatchFlagConfigScheduledChangeRequest) WebFlagScheduledChangesInput(webFlagScheduledChangesInput WebFlagScheduledChangesInput) ApiPatchFlagConfigScheduledChangeRequest {
	r.webFlagScheduledChangesInput = &webFlagScheduledChangesInput
	return r
}

func (r ApiPatchFlagConfigScheduledChangeRequest) Execute() (ScheduledChangesRep, *_nethttp.Response, error) {
	return r.ApiService.PatchFlagConfigScheduledChangeExecute(r)
}

/*
 * PatchFlagConfigScheduledChange Update scheduled changes workflow
 *  Update a scheduled change, overriding existing instructions with the new ones.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectKey The project key
 * @param featureFlagKey The feature flag's key
 * @param environmentKey The environment key
 * @param id The scheduled change id
 * @return ApiPatchFlagConfigScheduledChangeRequest
 */
func (a *ScheduledChangesApiService) PatchFlagConfigScheduledChange(ctx _context.Context, projectKey string, featureFlagKey string, environmentKey string, id string) ApiPatchFlagConfigScheduledChangeRequest {
	return ApiPatchFlagConfigScheduledChangeRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		featureFlagKey: featureFlagKey,
		environmentKey: environmentKey,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return ScheduledChangesRep
 */
func (a *ScheduledChangesApiService) PatchFlagConfigScheduledChangeExecute(r ApiPatchFlagConfigScheduledChangeRequest) (ScheduledChangesRep, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ScheduledChangesRep
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduledChangesApiService.PatchFlagConfigScheduledChange")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", _neturl.PathEscape(parameterToString(r.projectKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"featureFlagKey"+"}", _neturl.PathEscape(parameterToString(r.featureFlagKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentKey"+"}", _neturl.PathEscape(parameterToString(r.environmentKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.webFlagScheduledChangesInput == nil {
		return localVarReturnValue, nil, reportError("webFlagScheduledChangesInput is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webFlagScheduledChangesInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFlagConfigScheduledChangesRequest struct {
	ctx _context.Context
	ApiService *ScheduledChangesApiService
	projectKey string
	featureFlagKey string
	environmentKey string
	webPostFlagScheduledChangesInput *WebPostFlagScheduledChangesInput
	ignoreConflicts *bool
}

func (r ApiPostFlagConfigScheduledChangesRequest) WebPostFlagScheduledChangesInput(webPostFlagScheduledChangesInput WebPostFlagScheduledChangesInput) ApiPostFlagConfigScheduledChangesRequest {
	r.webPostFlagScheduledChangesInput = &webPostFlagScheduledChangesInput
	return r
}
func (r ApiPostFlagConfigScheduledChangesRequest) IgnoreConflicts(ignoreConflicts bool) ApiPostFlagConfigScheduledChangesRequest {
	r.ignoreConflicts = &ignoreConflicts
	return r
}

func (r ApiPostFlagConfigScheduledChangesRequest) Execute() (ScheduledChangesRep, *_nethttp.Response, error) {
	return r.ApiService.PostFlagConfigScheduledChangesExecute(r)
}

/*
 * PostFlagConfigScheduledChanges Create scheduled changes workflow
 *  Create scheduled changes for a feature flag. If the ignoreConficts query parameter is false and the new instructions would conflict with the current state of the feature flag or any existing scheduled changes, the request will fail. If the parameter is true and there are conflicts, the request will succeed as normal.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectKey The project key
 * @param featureFlagKey The feature flag's key
 * @param environmentKey The environment key
 * @return ApiPostFlagConfigScheduledChangesRequest
 */
func (a *ScheduledChangesApiService) PostFlagConfigScheduledChanges(ctx _context.Context, projectKey string, featureFlagKey string, environmentKey string) ApiPostFlagConfigScheduledChangesRequest {
	return ApiPostFlagConfigScheduledChangesRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		featureFlagKey: featureFlagKey,
		environmentKey: environmentKey,
	}
}

/*
 * Execute executes the request
 * @return ScheduledChangesRep
 */
func (a *ScheduledChangesApiService) PostFlagConfigScheduledChangesExecute(r ApiPostFlagConfigScheduledChangesRequest) (ScheduledChangesRep, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ScheduledChangesRep
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduledChangesApiService.PostFlagConfigScheduledChanges")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", _neturl.PathEscape(parameterToString(r.projectKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"featureFlagKey"+"}", _neturl.PathEscape(parameterToString(r.featureFlagKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentKey"+"}", _neturl.PathEscape(parameterToString(r.environmentKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.webPostFlagScheduledChangesInput == nil {
		return localVarReturnValue, nil, reportError("webPostFlagScheduledChangesInput is required and must be specified")
	}

	if r.ignoreConflicts != nil {
		localVarQueryParams.Add("ignoreConflicts", parameterToString(*r.ignoreConflicts, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webPostFlagScheduledChangesInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
